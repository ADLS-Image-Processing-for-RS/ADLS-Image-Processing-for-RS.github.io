{
  "hash": "7fdac4d5c63e49e629101d1ab8a70818",
  "result": {
    "engine": "knitr",
    "markdown": "\n# Raster Operations / Map algebra\n\n\n## Introduction\n\n- Map algebra can be defined as operations that modify or summarize raster cell values, with reference to surrounding cells, zones, or statistical functions that apply to every cell.\n- Map algebra divides raster operations into four subclasses:\n  1. **Local** or per-cell operations\n  2. **Focal** or neighborhood operations. Most often the output cell value is the result of a 3 x 3 input cell block\n  3. **Zonal** operations are similar to focal operations, but the surrounding pixel grid on which new values are computed can have irregular sizes and shapes\n  4. **Global** or per-raster operations. That means the output cell derives its value potentially from one or several entire rasters\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n## Global Operation (1)\n\n- The most common global operations are descriptive statistics for the entire raster dataset such as the minimum, maximum or mean value. \n- For example: What is the mean elevation value for Luxembourg?\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Elevation of Luxembourg](lesson2-1-operations_files/figure-html/fig-elev-1.png){#fig-elev width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# note: mean(r) does not work, since \"mean\" is used as a local operator\nmean_elev <- global(r, mean, na.rm = TRUE)\n\nmean_elev\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              mean\nelevation 348.3366\n```\n\n\n:::\n:::\n\n\n\n## Global Operation (2)\n\n- Another type of \"global\" operation is `distance`\n- This function calculates the distance from each cell to a specific target cell\n- For example, what is the distance from each cell to *Luxembourg City*, the capital of Luxembourg?\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lesson2-1-operations_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_dist <- distance(r, luxembourg_city)\nr_dist <- mask(r_dist, r)\n```\n:::\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lesson2-1-operations_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n\n## Zonal\n\n- Zonal operations apply an aggregation function to multiple raster cells\n- A second raster with categorical values define the \"zones\"\n\nWhat is the mean altitude *per municipality*?\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_vals <- zonal(r, zones, fun = mean, na.rm = TRUE)\n```\n:::\n\n\n\n\n::: {.cell .column-page layout-nrow=\"1\"}\n::: {.cell-output-display}\n![The original Zones (E.g. municipalities of Luxembourg)](lesson2-1-operations_files/figure-html/fig-zonal-1.png){#fig-zonal-1 width=672}\n:::\n\n::: {.cell-output-display}\n![Mean elevation per zone / per municipality](lesson2-1-operations_files/figure-html/fig-zonal-2.png){#fig-zonal-2 width=672}\n:::\n:::\n\n\n:::{.callout-note collapse=\"true}\n\n- The global operation can be seen as a special case of a zonal operation, where the only \"Zone\" is the entire dataset\n\n\n:::\n\n## Local (1)\n\n- Local operations comprise all cell-by-cell operations in one or several layers.\n- For example, we can classify the elevation into values above and below a certain threshold\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# first, create a boolean copy of the raster\nr_bool <- as.logical(r)\n\nmean_elev <- as.numeric(mean_elev)\nmean_elev\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 348.3366\n```\n\n\n:::\n\n```{.r .cell-code}\nr_bool[r > mean_elev] <- FALSE\nr_bool[r <= mean_elev] <- TRUE\n```\n:::\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lesson2-1-operations_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n\n## Local (2)\n\n- This type of (re-) classification is a very common operation\n- For more than 2 categories, we can use `classify`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncuts <- global(r, quantile, probs = c(0, .33, .66, 1), na.rm = TRUE)\n\nr_classify <- classify(r, as.numeric(cuts))\n\n# this next line just replaces the default labels with some custom ones\nlevels(r_classify) <- data.frame(ID = 0:2, category = c(\"low\",\"mid\",\"high\"))\n\np + tm_shape(r_classify) +\n    tm_raster(style = \"cat\",legend.show = TRUE, palette = \"viridis\", title = \"Elevation\") +\n    tm_layout(legend.show = TRUE)\n```\n\n::: {.cell-output-display}\n![](lesson2-1-operations_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n## Local (3)\n\n- Local operations are often used with multiple bands\n- For example, we could calculate the mean intensity values of red, green and blue:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl7 <- rast(system.file(\"tif/L7_ETMs.tif\",package = \"stars\"))\n\nnames(l7) <- c(\"B\", \"G\", \"R\", \"NIR\", \"SWIR\", \"MIR\")\n\nl7_rgb <- l7[[c(\"R\",\"G\", \"B\")]]\n\nplot(l7_rgb, nr = 1)\n```\n\n::: {.cell-output-display}\n![](lesson2-1-operations_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl7_rgb_mean <- mean(l7_rgb)\n\nplot(l7_rgb_mean)\n```\n\n::: {.cell-output-display}\n![](lesson2-1-operations_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n## Local (4)\n\n- In a more complex usecase, we could use the R, G and B band to calculate a grayscale value ($L^*$) using the following formula (from [here](https://stackoverflow.com/a/689547/4139249)):\n\n$$\\begin{aligned}\n\\gamma &= 2.2 \\\\\nL^* &= 116 \\times Y ^ {\\frac{1}{3}} - 16\\\\\nY &= 0.2126 \\times R^\\gamma+0.7152 \\times G^\\gamma+0.0722 \\times B^\\gamma \\\\\n\\end{aligned}\n$$\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- 2.2\n\nl7 <- l7/255 # scale values to 0-1\n\nY <- 0.2126 * l7[[\"R\"]]^g + 0.7152 * l7[[\"G\"]]^g + 0.0722 * l7[[\"B\"]]^g\n\nL <- 116* Y^(1/3)-16\n```\n:::\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lesson2-1-operations_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n## Focal {#sec-focal-1}\n\n- While local functions operate on one cell focal operations take into account a central (focal) cell *and its neighbors*. \n- The neighborhood (also named kernel, filter or moving window) under consideration is typically of size 3-by-3 cells (that is the central cell and its eight surrounding neighbors), but can take on any other size or shape as defined by the user. \n- A focal operation applies an aggregation function to all cells within the specified neighborhood, uses the corresponding output as the new value for the central cell, and moves on to the next central cell\n\n\n:::{#fig-focal}\n\n![](img/focal.png)\n\nNote how, depending on the size of your moving window, NA's are produced. Source: @lovelace2019\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfocal3by3 <- matrix(rep(1,9), ncol = 3)\n\n\nfocal11by11 <- matrix(rep(1,121), ncol = 11)\n\n\nr_foc3 <- focal(r, focal3by3, fun = mean, fillNA = TRUE)\n\nr_foc11 <- focal(r, focal11by11, fun = mean, fillNA = TRUE)\n```\n:::\n\n\n\n\n::: {.cell .column-page layout-nrow=\"1\"}\n::: {.cell-output-display}\n![Original values](lesson2-1-operations_files/figure-html/fig-focal2-1.png){#fig-focal2-1 width=672}\n:::\n\n::: {.cell-output-display}\n![Result of a 3x3 Focal Window](lesson2-1-operations_files/figure-html/fig-focal2-2.png){#fig-focal2-2 width=672}\n:::\n\n::: {.cell-output-display}\n![Result of a 11x11 Focal Window](lesson2-1-operations_files/figure-html/fig-focal2-3.png){#fig-focal2-3 width=672}\n:::\n:::\n\n\n:::{.callout-note collapse=\"true\"}\n\n- Note how the output raster is smaller as the focal window is larger (edge effect)\n\n:::\n\n## Focal weights (1)\n\n- The focal weights we used above were square and evenly weighted\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfocal3by3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    1    1\n[2,]    1    1    1\n[3,]    1    1    1\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfocal11by11\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]\n [1,]    1    1    1    1    1    1    1    1    1     1     1\n [2,]    1    1    1    1    1    1    1    1    1     1     1\n [3,]    1    1    1    1    1    1    1    1    1     1     1\n [4,]    1    1    1    1    1    1    1    1    1     1     1\n [5,]    1    1    1    1    1    1    1    1    1     1     1\n [6,]    1    1    1    1    1    1    1    1    1     1     1\n [7,]    1    1    1    1    1    1    1    1    1     1     1\n [8,]    1    1    1    1    1    1    1    1    1     1     1\n [9,]    1    1    1    1    1    1    1    1    1     1     1\n[10,]    1    1    1    1    1    1    1    1    1     1     1\n[11,]    1    1    1    1    1    1    1    1    1     1     1\n```\n\n\n:::\n:::\n\n\n\n## Focal weights (2)\n\n- However, we can also create uneven weights:\n\n\n\nFor example, a [laplacian filter](https://de.wikipedia.org/wiki/Laplace-Filter) is commonly used for edge detection.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlaplacian <- matrix(c(0,1,0,1,-4,1,0,1,0), nrow=3) \n\nlaplacian\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    0    1    0\n[2,]    1   -4    1\n[3,]    0    1    0\n```\n\n\n:::\n:::\n\n\nSo are the [sobel filters](https://en.wikipedia.org/wiki/Sobel_operator)\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]   -1    0    1\n[2,]   -2    0    2\n[3,]   -1    0    1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    1\n[2,]    0    0    0\n[3,]   -1   -2   -1\n```\n\n\n:::\n:::\n\n\n\n\n::: {.cell .column-page layout-nrow=\"1\"}\n::: {.cell-output-display}\n![Laplacian Filter](lesson2-1-operations_files/figure-html/fig-edgedetection-1.png){#fig-edgedetection-1 width=672}\n:::\n\n::: {.cell-output-display}\n![Sobel (x-direction)](lesson2-1-operations_files/figure-html/fig-edgedetection-2.png){#fig-edgedetection-2 width=672}\n:::\n\n::: {.cell-output-display}\n![SObel (y-direction)](lesson2-1-operations_files/figure-html/fig-edgedetection-3.png){#fig-edgedetection-3 width=672}\n:::\n:::\n\n\n\n## From cells to real world units (2)\n\n- We have been specifying our focal weights in terms of cell units\n- In most cases, it is more reasonable to work with real world units\n- The resolution of our raster is `0.008333333` (see `res(r)`) and since our raster is in `WGS84`, the units is \"degrees\". \n- To work with more managable units, we can convert the raster to a projected CRS that uses \"meters\", e.g. [EPSG 2169](https://epsg.io/2169)\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.008333333 0.008333333\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrs(r, parse = TRUE)\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"(output truncated)\"                             \n[2] \"...\"                                            \n[3] \"    ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\"\n[4] \"        LENGTHUNIT[\\\"metre\\\",1]],\"              \n[5] \"    ENSEMBLEACCURACY[2.0]],\"                    \n[6] \"...\"                                            \n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reproject to a \"projected\" CRS\nr_2169 <- project(r, \"EPSG:2169\")\n\ncrs(r_2169, parse = TRUE)\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"PROJCRS[\\\"LUREF / Luxembourg TM\\\",\"                   \n[2] \"BASEGEOGCRS[\\\"LUREF\\\",\"                               \n[3] \"    DATUM[\\\"Luxembourg Reference Frame\\\",\"            \n[4] \"        ELLIPSOID[\\\"International 1924\\\",6378388,297,\"\n[5] \"            LENGTHUNIT[\\\"metre\\\",1]]],\"               \n[6] \"...\"                                                  \n[7] \"(output truncated)\"                                   \n```\n\n\n:::\n:::\n\n\n\n## From cells to real world units (2)\n\n- The resolution of our new raster is 771.9714782 meters.\n- We can resample this to 1 km to simplify things\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres(r_2169)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 771.9715 771.9715\n```\n\n\n:::\n\n```{.r .cell-code}\n# first, create template raster with the same extent and 1km resolution\ntemplate <- rast(res = 1000, ext = ext(r_2169))\n\n# then, resample to this template\nr_2169 <- resample(r_2169, template)\n```\n:::\n\n\n\n## Focal weights with `focalMat`\n\n- Now that we have a raster with managable units and resolution, we can create specific focal *shapes* using `focalMat`.\n- `focalMat` can create circles, rectangles and gaussian shapes. The size of the shape is determined by `d`, which has different meanings for different shapes (always in the units of the CRS):\n  - *circle*: `d` specifies the circle radius\n  - *rectangle*: `d` can be 1 or 2 values, specifiying the dimensions of the rectangle\n  - *Gauss*: the size of *sigma*\n- The function returns a matrix which takes the raster resultion into account. (i.e. `d` is divided by the raster resolution)\n- The sum of all values in the matrix is 1\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfocal_circle <- focalMat(x = r_2169, d = 2000, \"circle\")\n\nfocal_circle\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]       [,2]       [,3]\n[1,] 0.00000000 0.09090909 0.00000000\n[2,] 0.09090909 0.09090909 0.09090909\n[3,] 0.09090909 0.09090909 0.09090909\n[4,] 0.09090909 0.09090909 0.09090909\n[5,] 0.00000000 0.09090909 0.00000000\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![A visual representation of the matrix / filter above](lesson2-1-operations_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfocal_gauss <- focalMat(x = r_2169, d = 2000, \"Gauss\")\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![A visual representation of the matrix / filter above](lesson2-1-operations_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n## Focal functions in terrain processing\n\n- Focal functions are used to calculate the slope of a specific location, e.g. using the algorithm by @horn1981\n- Similarly, calculating the aspect (azimuth) of a location is a very typical task when dealing with elevation data\n- These algorithms are used so often, that they are implemented in a dedicated function (`terrain()`)\n\n\n\n\n::: {.cell .column-page layout-nrow=\"1\"}\n\n```{.r .cell-code}\nterrain(r, \"slope\") |> plot()\nterrain(r, \"aspect\") |> plot()\n```\n\n::: {.cell-output-display}\n![Calculating slope using a predefined algorithm](lesson2-1-operations_files/figure-html/fig-terrain-1.png){#fig-terrain-1 width=672}\n:::\n\n::: {.cell-output-display}\n![Calculating aspect](lesson2-1-operations_files/figure-html/fig-terrain-2.png){#fig-terrain-2 width=672}\n:::\n:::\n\n\n\n",
    "supporting": [
      "lesson2-1-operations_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}