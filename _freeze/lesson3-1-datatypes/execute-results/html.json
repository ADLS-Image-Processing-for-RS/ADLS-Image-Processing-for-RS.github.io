{
  "hash": "2c004406853db9fb61bc1f98d3e0974d",
  "result": {
    "engine": "knitr",
    "markdown": "# Data Types, scale and offset {#sec-data-types}\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## Raster data types\n\n- While R and Python have a variety of data types including character strings, raster data is always stored as numeric\n- However, there are quite a number of numeric data types that can be used to store raster data, depending on the range of values and the precision required\n- The choice of data type can have a significant impact on the size of the file and the precision of the data stored\n- Since raster data is powered by GDAL, most raster based software (including R and Python) use the same data types\n- The numeric data types are supported by `gdal` are summarized in @tbl-datatypes\n\n:::{#tbl-datatypes}\n\n| Data type         | Minimum        | Maximum       | Size[^1]| Factor |\n|-------------------|---------------:|--------------:|--------:|-------:| \n| Byte              | 0              | 255           | 39M  \t |     1x |\n| UInt16            | 0              | 65,535        | 78M  \t |     2x |\n| Int16, CInt16     | -32,768        | 32,767        | 78M  \t |     2x |\n| UInt32            | 0              | 4,294,967,295 | 155M \t |    ~4x |\n| Int32, CInt32     | -2,147,483,648 | 2,147,483,647 | 155M \t |    ~4x |\n| Float32, CFloat32 | -3.4E38        | 3.4E38        | 155M \t |    ~4x |\n| Float64, CFloat64 | -1.79E308      | 1.79E308      | 309M \t |    ~8x | \n\n: The possible ranges of different datatypes in `gdal` (source: @amatulli2024)\n\n[^1]: Difference in file size using constant dataset (same values and resolution) and varying the datatype\n\n:::\n\n\n:::{.callout-note .notes collapse=\"true\"}\n\n\n- If you store categorical data, use integer datatype and store the corespondence in the metadata\n- Always be minimalistic about which datatype you need. \n- Question if you have a continuous value from 0 to 1, which datatype do you use?\n  - Not `Float32`! But Multiply by 100 and use `Byte` or by 1000 (if you need more precision) and use `UInt16`\n- Question: if you are measuring temperature, and your values are floating point ranging is -20 to +40 degrees, what datatype are you going to use?\n  - Not CFloat32!\n  - Multiply by 100 and use `CInt16`\n- Question: if you compute NDVI and have values in the range 0 - 1, what datatype do you use?\n  - Not `Float32`, but not `CInt16` either:\n  - Transform the values to 0 - 255\n\n:::\n\n\n\n\n## Choosing a data type\n\n- To minimize file size, it's important to choose the data type that best fits the range of values in the raster\n- At a first glance, it might seem that the numeric values we measured / calculated *determine* the datatype we use\n- However, we can transform the values to a different range to fit a different datatype\n- For example, if we have NDVI values ranging from -1 to 1, it might seem that we need to use `CFloat32` to store these values. However, we can *transform* (rescale) these values to the range 0 - 255 and store them as `Byte` datatype.\n\n\n\n\n\n## Rescaling / Transforming values to 0 - 255\n\nFrom [Wikipedia](https://en.wikipedia.org/wiki/Feature_scaling#Rescaling_(min-max_normalization)): \n\n> To rescale a range between an arbitrary set of values [a, b], the formula becomes: \n> $$x' = a + \\frac{(x-min(x))\\times(b - a)}{max(x)-min(x)}$$\n\nFor our usecase, we can consider: \n\n - $x'$ to be the *stored* value\n - $x$ to be the measured value\n - $a$ and $b$ to be the maximum, minimum value of `Byte` (0 and 255 respectively)\n - $min(x)$ and $max(x)$ the maximum and minimum measured values (`-1` and `1` respectively)\n \nWe can use these values and simplify the formula as follows:\n\n\\begin{align}\n\nx' &= 0 + \\frac{(x+1)\\times 255}{2} \\\\\n\nx' &= \\frac{255x+255}{2} \\\\\n\nx' &= 127.5x+127.5 \\\\\n\n\\end{align}\n\n\n## Rescaling NDVI values\n\n- We can now use this formula $x' = 127.5x+127.5$ to rescale NDVI values to the range 0 - 255\n- So, rather than storing the NDVI value 0.2, for example, we store the value 153\n- This rescaling is determined by two values: `scale` and `offset` (127.5 for both values in our case)\n\n\n\n## Precision\n\nNote that this transformation to 255 values limits our precision:\n\n- Our values are now limited to in their precision, since we only have 255 possible values\n- We can calculate the available precision like so: $\\frac{max(x)-min(x)}{b-a}$ \n- In our case this is $\\frac{1 - (-1)}{255-0} = 0.0078$. \n- Any measured / calculated NDVI value will be rounded to a multiple of 0.0078.\n\n\n## R Implementation for vectors\n\n- A generic way to implement this in R is as follows:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscale_minmax <- function(\n    x, \n    a = 0,          # the minimum value of the new range (default 0)\n    b = 255         # the maximum value of the new range (default 255)\n    ){\n  min_x = min(x) \n  max_x = max(x) \n  a + (x - min_x) * (b - a) / (max_x - min_x)\n}\n```\n:::\n\n\n\n\n\nTake the following example:\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# this creates 100 random NDVI values between -1 and 1\nndvi_measured <- runif(100, -1, 1)\n\nndvi_stored <- scale_minmax(ndvi_measured)\n\ntibble(ndvi_measured, ndvi_stored) |>\n  ggplot(aes(ndvi_measured, ndvi_stored)) + \n  geom_line(col = \"grey\") +\n  geom_point() +\n  labs(x = \"Measured NDVI (-1 to +1)\", y = \"Stored value (0 to 255)\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](lesson3-1-datatypes_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Restoring the original values\n\n- Imagine you stored the NDVI values in the range 0 - 255, stored these values in a Geotiff and sent it to a colleague.\n- To restore the original NDVI values the transformation ($x' = 127x+127.5$) needs to be known\n- More precisely, the `scale` and `offset` values need to be known\n- We can simply invert the transformation to get the original values back: $x = \\frac{x'-127.5}{127.5}$ \n\n\n## R implementation for rasters I\n\n- Since rescaling values is a common operation, it is supported by GDAL and therefore most raster libraries\n- Rather than transforming our values in memory, we can transform them when writing the raster to disk.\n- For this, we can use the arguments `scale = ` and `offset = ` in the `writeRaster` function\n- To use these arguments we need to calculate the `scale` and `offset` values first\n- Rewriting the formula above, we can calculate `scale` and `offset`:\n\n\n\\begin{align}\n\\text{scale} &= \\frac{b - a}{max(x)-min(x)} \\\\\n\\text{offset} &= \\frac{a \\times max(x) - b \\times min(x)}{max(x)-min(x)}\n\\end{align}\n\n- To implement this in R, I use two functions: `get_scale` and `get_offset`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_scale <- function(\n    x, \n    a = 0,          # the minimum value of the new range (default 0)\n    b = 255         # the maximum value of the new range (default 255)\n    ){\n  min_x = min(x)\n  max_x = max(x)\n  \n  scale <- (b - a) / (max_x - min_x)\n  \n  scale\n}\n\nget_offset <- function(\n    x, \n    a = 0,          \n    b = 255\n    ){\n  min_x = min(x)\n  max_x = max(x)\n  offset <- (a * max_x - b * min_x) / (max_x - min_x)\n  \n  offset\n}\n\n\nget_scale(ndvi_measured)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 130.0526\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## R implementation for rasters II\n\n- The new function `get_scale_offset` works nicely with vectors, but not with rasters\n- The reason it does not work for raster is that `min(x)` (and `max(x)`) are *local* and not *global* functions\n  - They return the minimum / maximum value *per cell over all bands*, not the global minimum / maximum value\n  - To calculate the global minimum and maximum value, we can either use `global`, or the slightly faster `minmax` function\n- Additionally, the `writeRaster` function will *divide* by `scale` and *subtract* `offset` from the values (see `writeRaster`), so we need to invert the two values\n- This is how this is implemented in R:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_scale2 <- function(\n    x, \n    a = 0,          \n    b = 255         \n    ){\n  library(terra)\n  min_max = minmax(x) \n  min_x <- min_max[1,1]\n  max_x <- min_max[2,1]\n\n  scale <- (b - a) / (max_x - min_x)\n  \n  1/scale           # invert the scale, sincd writeRaster divides by scale\n}\n\n\nget_offset2 <- function(\n    x, \n    a = 0,          \n    b = 255\n    ){\n  library(terra)\n  min_max = minmax(x) \n  min_x <- min_max[1,1]   \n  max_x <- min_max[2,1]\n  \n  offset <- (a * max_x - b * min_x) / (max_x - min_x)\n  \n  offset * -1       # invert the offset, since writeRaster subtracts the offset\n}\n```\n:::\n\n\n\n\n\n\n## R implementation for rasters: example \n\n- Let's import a raster, calculate the `scale` and `offset` values and use these values to write to disk\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(terra)\n\nelev <- rast(system.file(\"ex/elev.tif\", package=\"terra\"))\n\nplot(elev, main = paste(minmax(elev),collapse = \"-\"))\n```\n\n::: {.cell-output-display}\n![](lesson3-1-datatypes_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# write to disk with the minimum data type that fits the range \n# without transformation \n\nscale <- get_scale2(elev)\noffset <- get_offset2(elev)\n\nwriteRaster(\n  elev, \n  \"data-out/datatypes/INT1U.tif\",\n  # datatype = \"INT1U\", \n  overwrite = TRUE, \n  scale = scale, \n  offset = offset\n  )\n```\n:::\n\n\n\n\n\n\n## R implementation for rasters: example \n\n- Since GDAL stores the `scale` and `offset` values in the metadata, any software powered by GDAL will restore the original values on import\n- In other words, if you run `rast(\"data-out/datatypes/INT1U.tif\")` you will not notice the values were internally stored using 0 - 255. Instead, you will retrieve the original values.\n- To finish off, let's compare the file sizes of the raster stored as `INT1U` (Byte) and `FLT8S` (Float32)\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6199451\n```\n\n\n:::\n:::\n",
    "supporting": [
      "lesson3-1-datatypes_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}